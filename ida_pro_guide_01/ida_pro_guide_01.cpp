// ida_pro_guide_01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//之前对IDA就是简单分析下函数，只会一个F5转c代码
//其他的就是配合adb做一些动态调试
//用到什么就去google、百度，没有系统学习
//打算花点业余时间看看这本书


// 
//参考《IDA Pro权威指南》
//


//基本反汇编算法
//
//第一步，确定反汇编代码区域，最常见为可执行文件
// Windows使用可移植可执行格式 Portable Executable，PE
// Unix系统常用可执行和链接格式 Executable and linking format，ELF
// 这类文件格式有一种机制来确定文件中包含代码和入口点的位置（通常是层级文件头形式）
// 
//第二步，得到起始地址后，就是读取该地址（偏移量）所包含的值
// 执行一次表查找
// 将二进制操作码的值与它的汇编语言助记符对应起来
// 
//第三步，或去指令并解码操作数后
// 对汇编语言等价形式进行格式化并输出
// 例如，x86两种主要格式为intel格式和AT&T格式
//
//第四步，重复上述过程，直至反汇编完所有指令
// 
//线性扫描和递归下降是两种主要的算法
//


//工具
// 
//file
// 通过检查文件中的某些特定字段来确定文件类型
// 如
// #!/bin/sh为shell脚本
// <html>为html文档
// 而对于非ascii内容的文件，会搜索某些文件类型的特有标签值（幻数）
// 如
// 4D 5A -> MZ（MS-DOS架构师姓名首字母缩写） 为PE文件格式
// CA FE BA BE -> Java.class的文件开头，单纯因为cafebabe是一个好记的十六进制字符串
// 幻数文件（magic file），常见的位置有
// /usr/share/file/magic
// /usr/share/misc/magic
// /etc/magic
// 
//PE Tools
// 在进程列表中，可以将一个进程内存映像转储到某个文件，也可以使用PE Sniffer确定可执行文件由何种编译器构建
// 识别该文件是否已被某种已知模糊工具处理
// 还可以使用内嵌编辑器修改文件头，将模糊版本重建成有效PE
//PEiD
// 与上面类似
// 
//nm
// 将源文件编译成目标文件时，编译器会嵌入一些全局符号的位置信息，以便链接器在组合目标文件时能够解析对这些符号的引用
// nm的作用就是，列举目标文件中的符号
// 
//ldd
// 创建可执行文件时，必须解析该文件引用的任何库函数地址
// 链接器有两种方法解析对库函数的调用，静态链接和动态链接
// 静态链接会直接将程序目标文件和所需库文件组合，这样运行时就不需要额外的文件，只是生成文件更大，改库组件必须重新生成
// 动态库则是将所需库（.dll或.so）的引用插入可执行文件，库文件独立，升级库更方便，替换文件即可
// ldd时列举任何可执行文件所需的动态库
// linux和BSD系统直接提供ldd
// OS X使用otool工具
// win中使用vs套件中的dumpbin
// 
//objdump
// 提取目标文件中各种信息，包括
// 节头部、专用头部、调试信息、符号信息、反汇编代码清单
// 时GNU binutils工具套件的一部分
// 
//c++file
// 将每个输入的名称看成时改编后的名称，并设法确定用于生成该名称的编译器
// 配合nm使用，可以得到函数的原始名称
// 例如
// nm cpp_test | grep func_name | c++filt
// 
//strings
// 有时，需要确定，文件中是否包含字符串
// 字符串的定义
// 简单定义为由可打印字符组成的连续字符序列
// 此外，还需要指定一个最小长度和一个特定的字符集
// 可以搜索至少包含4个连续可打印ASCII字符的字符串
// 通常，这类字符串不会收到文件结构限制，在ELF二进制文件搜索字符串就跟在word文档中搜索字符串一样
// strings可以提取文件中的字符串内容
// 大致包括
// 程序输出内容
// 函数名称、库名称
// 
//反汇编器
// PE、ELF和MACH-O文件，分别可以用dumpbin、objdump、otool进行反汇编
// 但他们无法处理任意格式的二进制数据块
// 有两个用于x86指令集的流式反汇编器，ndisasm和diStorm
// 分析网络数据包中可能包含shellcode的网络攻击时，可以采用流式反汇编器
// 
// 
//
//从IDA平时的使用来看，是这些工具的一种集成封装
//


//IDA
// 
//本质是递归下降反编译器，出自Hex-Rays
// 
//反盗版策略
// 1 每一份IDA带有水印，如果IDA出现在盗版站点，就能追踪到购买者，并列入黑名单
// 2 扫描局域网中运行的其他IDA程序，会在一个端口上广播一个UDP包，看同子网中是否有其他相同许可证密钥的IDA实例在运行
//   如果存在过多实例，则IDA拒绝启动（同一台上可以运行多个实例）
// 3 使用密钥文件将每一个购买者与产品联系，启动时，搜索ida.key文件
// 
//支持资源
// 自带帮助文档
// Hex-Rays支持页面
// openRCE.org
// RCE论坛  woodmann.com
// IDA palace  old.idapalace.net
// llfak博客
// 
//目录结构
// cfg 包含各种配置文件
// idc 内置脚本语言idc所需的核心文件
// ids 包含一些符号文件
// loaders 文件加载过程中用于识别和解析PE或ELF等已知格式的IDA扩展
// plugins 附加功能的IDA模块
// procs 包含已安装的IDA版本所支持的处理器模块
// sig 包含各种模式匹配操作重利用的现用代码签名
// til 包含一些类型库信息，IDA通过这些信息记录特定于各种编译器库的数据结构的布局
// 
//IDA用户界面
// 大量热键
// 不提供撤销功能
//


int main()
{
    std::cout << "Hello World!\n";
}
