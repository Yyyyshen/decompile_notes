// ida_pro_guide_02.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//IDA基本用法
//


//IDA入门
// 
//基本使用日常中已经有所了解
// 
//控制台两个基本点
// 可以开始浏览了（但不能改）
// You may start to explore the input file right now.
// 初始化分析完成
// The initial autoanalysis has been finished.
// 


//IDA数据显示窗口
// 
//切换基于图形的流程视图和面向文本的列表试图
// 在IDA View-A界面 空格键
// 
//流程图形视图
// 条件控制流中：执行分支的边默认为绿色，不执行分支默认为红色
// 普通流程中，使用蓝色箭头
// 
//多窗口
// views-》open subviews-》disassembly
// 
//设置行前缀
// options-》general-》disassembly-》line prefix
// 启用后图形试图每条语句前也会有偏移地址信息
// 
//函数窗口
// 记录了函数名，起始偏移地址、函数长度、一些函数标记
// 
//16进制窗口
// Hex View-n，可与反汇编窗口同步，同样支持多窗口，可分别对应多个不同的IDA View
// 
//strings
// view-》open subviews-》strings，开启字符串窗口
// IDA默认扫描至少包含5个字符的C风格、以null结尾的7位ASCII字符
// 另外可以setup设置其他格式，如windows程序，可以搜索Unicode等
// 
//names窗口
// 列举二进制文件的所有全局名称（指对一个程序虚拟地址的符号描述）
// 
//反汇编代码清单中的位置名称
// sub_xxxxx 地址xxxxx处的子例程
// loc_xxxxx 一个指令
// byte_xxxxx 一个8位数据
// word_xxxxx 一个16位数据
// dword_xxxxx 32位数据
// unk_xxxxx 未知大小数据
// 
//function calls
// 显示一个函数在不同位置被调用
// 以及该函数调用的其他函数
//


//反汇编导航
// 
//双击导航
// 大多数情况下，双击感兴趣的地方就能导航到该位置
// 
//跳转到地址
// 反汇编窗口按虚拟地址逐行显示，可滚动窗口查找
// 在其他带地址的窗口（如函数窗口）双击可达
// 使用搜索功能
// 通过使用jump-》jump to address功能对话框
// 
//历史记录
// 导航到下一个位置后，可以返回前一个位置
// 快捷键esc
// 菜单栏jump-》jump to previous position
// 工具栏上的箭头型导航前进/后退按钮
// 
//栈帧
// 是在程序运行时栈中分配的内存块，专门用于特定的函数调用
// 编译器通过栈帧使得对函数参数和局部变量进行分配和释放的过程对程序员透明
// 将控制权交给函数之前，编译器会插入代码，将函数放入栈帧，并分配足够内存
// 函数返回地址也存储在新栈帧内，这使递归调用称为可能，每次调用都有自己的栈帧，与前一次分隔开
// 
//调用约定
// C调用约定
// _cdecl x86体系下许多C编译器使用的默认调用约定
// 此约定规定，调用方从右到左将参数压栈，完成操作后，调用方负责从栈中清理参数
// 无论多少个参数，最左（第一个）参数总是位于栈顶，可以轻松找到
// 十分适用于参数数量可变的函数，如printf
// 指令在返回后，会立即对程序栈指针调整，调用方很清楚它传了几个参数，而被调用方则很难这样调整
/*
;demo_cdecl(1,2,3);
push 3
push 2
push 1                  ;参数压栈
call demo_cdecl         ;调用函数
add esp,12              ;调整栈指针

;另一种方式

mov [esp+8],3
mov [esp+4],2           ;将参数放入对应栈地址，但没有栈操作所以栈指针值没有变化
mov [esp],1             ;第一个参数刚好在栈顶
call demo_cdecl         ;调用函数
						;无需调整栈指针
*/
// 
// 标准调用约定
// _stdcall 由微软定义的一种调用约定
// 也是从右到左顺序将参数放在栈上
// 区别在于，由被调用的函数负责删除栈中的函数参数
// 对被调用函数而言，必须知道栈中有多少个参数，只有参数数量固定时才行，printf这类可变参数函数不能使用stdcall
// 优点时每次调用后不需要通过代码从栈中清除参数，生成体积稍小、速度稍快的程序
// 微软对所有dll输出的参数数量固定的函数使用stdcall约定
/*
void _stdcall demo_stdcall(int x,int y);
;x86中有ret指令的特殊形式，加上一个数字，从栈顶提取返回地址，并给栈指针加上数字值
ret 8                   ;32位体系下，demo_stdcall返回后栈地址加上2×sizeof(int)
*/
// 
// x86 fastcall约定
// fastcall 是stdcall约定的一个变体
// 向CPU寄存器（ECX，EDX，而非栈）最多传递两个参数（有更多其余参数还使用栈，从右到左）
// 也是函数自己调整栈，清除参数
/*
void fastcall demo_fastcall(1,2,3,4)
push 4                  ;超过2个的参数从右向左入栈
push 3                  ;此时栈顶是第三个参数
mov edx,2               ;前两个参数直接放入寄存器
mov ecx,1               ;
call demo_fastcall      ;调用函数
						;由被调用函数调整栈，可能语句为 ret 8
*/
// 
// C++调用约定
// 通过this指针，指向调用函数的对象
// 用于调用函数的对象地址必须由调用方提供，因此，在调用非静态成员函数时，需要作为参数提供
// 而程序员不需要自己编写，这一般是由编译器来做的，各有不同技巧
// Microsoft Visual C++提供thiscall调用约定，它将this指针传到ECX寄存器，并要求函数清除栈中的参数
// GNU g++编译器将this看成任何非静态成员函数的第一个隐含参数，其他方面与cdecl约定相同，也就是this指针在栈顶，函数完成后调用方负责调整栈指针
// 
//局部变量布局
// 参数有调用约定，但局部变量没有
// 编译器算出函数的局部变量所需空间
// 确定这些变量是否可在CPU寄存器中分配，或者他们是否必须在程序栈上分配
// 与函数调用方和被调用方都无关
void bar(int j, int k) {}
void demo_stackframe(int a, int b, int c) {
	int x;
	char buffer[64];
	int y;
	int z;
	bar(z, y);
}
// 计算得出局部变量需要64+3*4=76字节栈空间，调用约定可能是stdcall或cdecl，栈帧相同
/* 进入函数demo_stackframe后
	 +-----------+-----------+
	 |	  变量   |   偏移量  |
	 +-----------+-----------+
	 |	   z	 |	[esp]	 | -|
	 +-----------+-----------+	|
	 |	   y	 |	[esp+4]	 |	|
	 +-----------+-----------+	|-局部变量
	 |	 buffer	 |	[esp+8]  |	|
	 +-----------+-----------+	|
	 |	   x	 |	[esp+72] | -|
	 +-----------+-----------+
	 | saved eip |	[esp+76] |		sub esp,76
	 +-----------+-----------+
	 |	   a	 |	[esp+80] | -|
	 +-----------+-----------+  |
	 |	   b	 |	[esp+84] |  |-参数
	 +-----------+-----------+  |
	 |	   c	 |	[esp+88] | -|
	 +-----------+-----------+

	 调用bar时
	 push dword [esp+4]		;push y
	 push dword [esp+4]		;push z，这里需要注意，基于esp的帧，push了esp+4后，偏移量发生调整，z的新偏移量为esp+4
	 call bar				;调用bar
	 add esp,8				;cdecl约定，调用方调整栈指针
	 函数完成时
	 add esp,76				;调整esp指向保存返回的地址（saved eip）
	 ret					;返回调用方
*/
// 
//IDA栈视图
// 栈帧是个运行时概念，但不意味着静态分析时可以忽略栈帧概念
// 
//搜索数据库
// 文本搜索
// 二进制搜索
//


//反汇编操作
// 
//IDA可以根据需要修改反汇编代码
// 必要时，自动处理各种操作
// 如全局搜索和替换
// 对指令和数据重新格式化
// （但没有撤销）
// 
//名称与命名
// 已命名名称（参数、变量、位置、寄存器）可以自己修改为更明确的标识，快捷键n或右键
// 
//注释
// 快捷键 ; :
// 
//代码转换
// 数据转代码
// 代码转数据
// 指定一个指令序列为函数
// 更改现有函数的起始或结束地址
// 更改指令操作数的显示格式
// 
//


//数据类型和数据结构
// 
//
//


int main()
{
	std::cout << "Hello World!\n";
}
